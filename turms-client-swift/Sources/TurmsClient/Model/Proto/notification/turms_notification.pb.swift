// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: notification/turms_notification.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct TurmsNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Common => [1, 3]
    public var timestamp: Int64 {
        get { return _storage._timestamp }
        set { _uniqueStorage()._timestamp = newValue }
    }

    /// Response => [4, 9]
    /// "request_id" is used to tell the client that
    /// this notification is a response to the specific request
    public var requestID: Int64 {
        get { return _storage._requestID ?? 0 }
        set { _uniqueStorage()._requestID = newValue }
    }

    /// Returns true if `requestID` has been explicitly set.
    public var hasRequestID: Bool { return _storage._requestID != nil }
    /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
    public mutating func clearRequestID() { _uniqueStorage()._requestID = nil }

    public var code: Int32 {
        get { return _storage._code ?? 0 }
        set { _uniqueStorage()._code = newValue }
    }

    /// Returns true if `code` has been explicitly set.
    public var hasCode: Bool { return _storage._code != nil }
    /// Clears the value of `code`. Subsequent reads from it will return its default value.
    public mutating func clearCode() { _uniqueStorage()._code = nil }

    public var reason: String {
        get { return _storage._reason ?? String() }
        set { _uniqueStorage()._reason = newValue }
    }

    /// Returns true if `reason` has been explicitly set.
    public var hasReason: Bool { return _storage._reason != nil }
    /// Clears the value of `reason`. Subsequent reads from it will return its default value.
    public mutating func clearReason() { _uniqueStorage()._reason = nil }

    public var data: TurmsNotification.DataMessage {
        get { return _storage._data ?? TurmsNotification.DataMessage() }
        set { _uniqueStorage()._data = newValue }
    }

    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool { return _storage._data != nil }
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() { _uniqueStorage()._data = nil }

    /// Notification => [10, 15]
    /// "requester_id" only exists when a requester triggers a notification to its recipients
    /// Note: Do not move "requester_id" to TurmsRequest because it requires rebuilding
    /// a new TurmsNotification when recipients need "requester_id".
    public var requesterID: Int64 {
        get { return _storage._requesterID ?? 0 }
        set { _uniqueStorage()._requesterID = newValue }
    }

    /// Returns true if `requesterID` has been explicitly set.
    public var hasRequesterID: Bool { return _storage._requesterID != nil }
    /// Clears the value of `requesterID`. Subsequent reads from it will return its default value.
    public mutating func clearRequesterID() { _uniqueStorage()._requesterID = nil }

    public var closeStatus: Int32 {
        get { return _storage._closeStatus ?? 0 }
        set { _uniqueStorage()._closeStatus = newValue }
    }

    /// Returns true if `closeStatus` has been explicitly set.
    public var hasCloseStatus: Bool { return _storage._closeStatus != nil }
    /// Clears the value of `closeStatus`. Subsequent reads from it will return its default value.
    public mutating func clearCloseStatus() { _uniqueStorage()._closeStatus = nil }

    public var relayedRequest: TurmsRequest {
        get { return _storage._relayedRequest ?? TurmsRequest() }
        set { _uniqueStorage()._relayedRequest = newValue }
    }

    /// Returns true if `relayedRequest` has been explicitly set.
    public var hasRelayedRequest: Bool { return _storage._relayedRequest != nil }
    /// Clears the value of `relayedRequest`. Subsequent reads from it will return its default value.
    public mutating func clearRelayedRequest() { _uniqueStorage()._relayedRequest = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DataMessage {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var kind: TurmsNotification.DataMessage.OneOf_Kind?

        /// Common
        public var long: Int64 {
            get {
                if case let .long(v)? = kind { return v }
                return 0
            }
            set { kind = .long(newValue) }
        }

        public var string: String {
            get {
                if case let .string(v)? = kind { return v }
                return String()
            }
            set { kind = .string(newValue) }
        }

        public var longsWithVersion: LongsWithVersion {
            get {
                if case let .longsWithVersion(v)? = kind { return v }
                return LongsWithVersion()
            }
            set { kind = .longsWithVersion(newValue) }
        }

        public var stringsWithVersion: StringsWithVersion {
            get {
                if case let .stringsWithVersion(v)? = kind { return v }
                return StringsWithVersion()
            }
            set { kind = .stringsWithVersion(newValue) }
        }

        /// Conversation
        public var conversations: Conversations {
            get {
                if case let .conversations(v)? = kind { return v }
                return Conversations()
            }
            set { kind = .conversations(newValue) }
        }

        /// Message
        public var messages: Messages {
            get {
                if case let .messages(v)? = kind { return v }
                return Messages()
            }
            set { kind = .messages(newValue) }
        }

        public var messagesWithTotalList: MessagesWithTotalList {
            get {
                if case let .messagesWithTotalList(v)? = kind { return v }
                return MessagesWithTotalList()
            }
            set { kind = .messagesWithTotalList(newValue) }
        }

        /// User
        public var userSession: UserSession {
            get {
                if case let .userSession(v)? = kind { return v }
                return UserSession()
            }
            set { kind = .userSession(newValue) }
        }

        public var userInfosWithVersion: UserInfosWithVersion {
            get {
                if case let .userInfosWithVersion(v)? = kind { return v }
                return UserInfosWithVersion()
            }
            set { kind = .userInfosWithVersion(newValue) }
        }

        public var userOnlineStatuses: UserOnlineStatuses {
            get {
                if case let .userOnlineStatuses(v)? = kind { return v }
                return UserOnlineStatuses()
            }
            set { kind = .userOnlineStatuses(newValue) }
        }

        public var userFriendRequestsWithVersion: UserFriendRequestsWithVersion {
            get {
                if case let .userFriendRequestsWithVersion(v)? = kind { return v }
                return UserFriendRequestsWithVersion()
            }
            set { kind = .userFriendRequestsWithVersion(newValue) }
        }

        public var userRelationshipGroupsWithVersion: UserRelationshipGroupsWithVersion {
            get {
                if case let .userRelationshipGroupsWithVersion(v)? = kind { return v }
                return UserRelationshipGroupsWithVersion()
            }
            set { kind = .userRelationshipGroupsWithVersion(newValue) }
        }

        public var userRelationshipsWithVersion: UserRelationshipsWithVersion {
            get {
                if case let .userRelationshipsWithVersion(v)? = kind { return v }
                return UserRelationshipsWithVersion()
            }
            set { kind = .userRelationshipsWithVersion(newValue) }
        }

        public var nearbyUsers: NearbyUsers {
            get {
                if case let .nearbyUsers(v)? = kind { return v }
                return NearbyUsers()
            }
            set { kind = .nearbyUsers(newValue) }
        }

        /// Group
        public var groupInvitationsWithVersion: GroupInvitationsWithVersion {
            get {
                if case let .groupInvitationsWithVersion(v)? = kind { return v }
                return GroupInvitationsWithVersion()
            }
            set { kind = .groupInvitationsWithVersion(newValue) }
        }

        public var groupJoinQuestionAnswerResult: GroupJoinQuestionsAnswerResult {
            get {
                if case let .groupJoinQuestionAnswerResult(v)? = kind { return v }
                return GroupJoinQuestionsAnswerResult()
            }
            set { kind = .groupJoinQuestionAnswerResult(newValue) }
        }

        public var groupJoinRequestsWithVersion: GroupJoinRequestsWithVersion {
            get {
                if case let .groupJoinRequestsWithVersion(v)? = kind { return v }
                return GroupJoinRequestsWithVersion()
            }
            set { kind = .groupJoinRequestsWithVersion(newValue) }
        }

        public var groupJoinQuestionsWithVersion: GroupJoinQuestionsWithVersion {
            get {
                if case let .groupJoinQuestionsWithVersion(v)? = kind { return v }
                return GroupJoinQuestionsWithVersion()
            }
            set { kind = .groupJoinQuestionsWithVersion(newValue) }
        }

        public var groupMembersWithVersion: GroupMembersWithVersion {
            get {
                if case let .groupMembersWithVersion(v)? = kind { return v }
                return GroupMembersWithVersion()
            }
            set { kind = .groupMembersWithVersion(newValue) }
        }

        public var groupsWithVersion: GroupsWithVersion {
            get {
                if case let .groupsWithVersion(v)? = kind { return v }
                return GroupsWithVersion()
            }
            set { kind = .groupsWithVersion(newValue) }
        }

        /// Storage
        public var storageResourceInfos: StorageResourceInfos {
            get {
                if case let .storageResourceInfos(v)? = kind { return v }
                return StorageResourceInfos()
            }
            set { kind = .storageResourceInfos(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Kind: Equatable {
            /// Common
            case long(Int64)
            case string(String)
            case longsWithVersion(LongsWithVersion)
            case stringsWithVersion(StringsWithVersion)
            /// Conversation
            case conversations(Conversations)
            /// Message
            case messages(Messages)
            case messagesWithTotalList(MessagesWithTotalList)
            /// User
            case userSession(UserSession)
            case userInfosWithVersion(UserInfosWithVersion)
            case userOnlineStatuses(UserOnlineStatuses)
            case userFriendRequestsWithVersion(UserFriendRequestsWithVersion)
            case userRelationshipGroupsWithVersion(UserRelationshipGroupsWithVersion)
            case userRelationshipsWithVersion(UserRelationshipsWithVersion)
            case nearbyUsers(NearbyUsers)
            /// Group
            case groupInvitationsWithVersion(GroupInvitationsWithVersion)
            case groupJoinQuestionAnswerResult(GroupJoinQuestionsAnswerResult)
            case groupJoinRequestsWithVersion(GroupJoinRequestsWithVersion)
            case groupJoinQuestionsWithVersion(GroupJoinQuestionsWithVersion)
            case groupMembersWithVersion(GroupMembersWithVersion)
            case groupsWithVersion(GroupsWithVersion)
            /// Storage
            case storageResourceInfos(StorageResourceInfos)

            #if !swift(>=4.1)
                public static func == (lhs: TurmsNotification.DataMessage.OneOf_Kind, rhs: TurmsNotification.DataMessage.OneOf_Kind) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.long, .long): return {
                            guard case let .long(l) = lhs, case let .long(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.string, .string): return {
                            guard case let .string(l) = lhs, case let .string(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.longsWithVersion, .longsWithVersion): return {
                            guard case let .longsWithVersion(l) = lhs, case let .longsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.stringsWithVersion, .stringsWithVersion): return {
                            guard case let .stringsWithVersion(l) = lhs, case let .stringsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.conversations, .conversations): return {
                            guard case let .conversations(l) = lhs, case let .conversations(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.messages, .messages): return {
                            guard case let .messages(l) = lhs, case let .messages(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.messagesWithTotalList, .messagesWithTotalList): return {
                            guard case let .messagesWithTotalList(l) = lhs, case let .messagesWithTotalList(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userSession, .userSession): return {
                            guard case let .userSession(l) = lhs, case let .userSession(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userInfosWithVersion, .userInfosWithVersion): return {
                            guard case let .userInfosWithVersion(l) = lhs, case let .userInfosWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userOnlineStatuses, .userOnlineStatuses): return {
                            guard case let .userOnlineStatuses(l) = lhs, case let .userOnlineStatuses(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userFriendRequestsWithVersion, .userFriendRequestsWithVersion): return {
                            guard case let .userFriendRequestsWithVersion(l) = lhs, case let .userFriendRequestsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userRelationshipGroupsWithVersion, .userRelationshipGroupsWithVersion): return {
                            guard case let .userRelationshipGroupsWithVersion(l) = lhs, case let .userRelationshipGroupsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.userRelationshipsWithVersion, .userRelationshipsWithVersion): return {
                            guard case let .userRelationshipsWithVersion(l) = lhs, case let .userRelationshipsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.nearbyUsers, .nearbyUsers): return {
                            guard case let .nearbyUsers(l) = lhs, case let .nearbyUsers(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupInvitationsWithVersion, .groupInvitationsWithVersion): return {
                            guard case let .groupInvitationsWithVersion(l) = lhs, case let .groupInvitationsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupJoinQuestionAnswerResult, .groupJoinQuestionAnswerResult): return {
                            guard case let .groupJoinQuestionAnswerResult(l) = lhs, case let .groupJoinQuestionAnswerResult(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupJoinRequestsWithVersion, .groupJoinRequestsWithVersion): return {
                            guard case let .groupJoinRequestsWithVersion(l) = lhs, case let .groupJoinRequestsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupJoinQuestionsWithVersion, .groupJoinQuestionsWithVersion): return {
                            guard case let .groupJoinQuestionsWithVersion(l) = lhs, case let .groupJoinQuestionsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupMembersWithVersion, .groupMembersWithVersion): return {
                            guard case let .groupMembersWithVersion(l) = lhs, case let .groupMembersWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.groupsWithVersion, .groupsWithVersion): return {
                            guard case let .groupsWithVersion(l) = lhs, case let .groupsWithVersion(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.storageResourceInfos, .storageResourceInfos): return {
                            guard case let .storageResourceInfos(l) = lhs, case let .storageResourceInfos(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: return false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension TurmsNotification: @unchecked Sendable {}
    extension TurmsNotification.DataMessage: @unchecked Sendable {}
    extension TurmsNotification.DataMessage.OneOf_Kind: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "im.turms.proto"

extension TurmsNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TurmsNotification"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        4: .standard(proto: "request_id"),
        5: .same(proto: "code"),
        6: .same(proto: "reason"),
        7: .same(proto: "data"),
        10: .standard(proto: "requester_id"),
        11: .standard(proto: "close_status"),
        12: .standard(proto: "relayed_request"),
    ]

    fileprivate class _StorageClass {
        var _timestamp: Int64 = 0
        var _requestID: Int64?
        var _code: Int32?
        var _reason: String?
        var _data: TurmsNotification.DataMessage?
        var _requesterID: Int64?
        var _closeStatus: Int32?
        var _relayedRequest: TurmsRequest?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _timestamp = source._timestamp
            _requestID = source._requestID
            _code = source._code
            _reason = source._reason
            _data = source._data
            _requesterID = source._requesterID
            _closeStatus = source._closeStatus
            _relayedRequest = source._relayedRequest
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularInt64Field(value: &_storage._timestamp)
                case 4: try try decoder.decodeSingularInt64Field(value: &_storage._requestID)
                case 5: try try decoder.decodeSingularInt32Field(value: &_storage._code)
                case 6: try try decoder.decodeSingularStringField(value: &_storage._reason)
                case 7: try try decoder.decodeSingularMessageField(value: &_storage._data)
                case 10: try try decoder.decodeSingularInt64Field(value: &_storage._requesterID)
                case 11: try try decoder.decodeSingularInt32Field(value: &_storage._closeStatus)
                case 12: try try decoder.decodeSingularMessageField(value: &_storage._relayedRequest)
                default: break
                }
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._timestamp != 0 {
                try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 1)
            }
            try { if let v = _storage._requestID {
                try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
            } }()
            try { if let v = _storage._code {
                try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
            } }()
            try { if let v = _storage._reason {
                try visitor.visitSingularStringField(value: v, fieldNumber: 6)
            } }()
            try { if let v = _storage._data {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            } }()
            try { if let v = _storage._requesterID {
                try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
            } }()
            try { if let v = _storage._closeStatus {
                try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
            } }()
            try { if let v = _storage._relayedRequest {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: TurmsNotification, rhs: TurmsNotification) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._timestamp != rhs_storage._timestamp { return false }
                if _storage._requestID != rhs_storage._requestID { return false }
                if _storage._code != rhs_storage._code { return false }
                if _storage._reason != rhs_storage._reason { return false }
                if _storage._data != rhs_storage._data { return false }
                if _storage._requesterID != rhs_storage._requesterID { return false }
                if _storage._closeStatus != rhs_storage._closeStatus { return false }
                if _storage._relayedRequest != rhs_storage._relayedRequest { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension TurmsNotification.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = TurmsNotification.protoMessageName + ".Data"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "long"),
        2: .same(proto: "string"),
        3: .standard(proto: "longs_with_version"),
        4: .standard(proto: "strings_with_version"),
        5: .same(proto: "conversations"),
        6: .same(proto: "messages"),
        7: .standard(proto: "messages_with_total_list"),
        8: .standard(proto: "user_session"),
        9: .standard(proto: "user_infos_with_version"),
        10: .standard(proto: "user_online_statuses"),
        11: .standard(proto: "user_friend_requests_with_version"),
        12: .standard(proto: "user_relationship_groups_with_version"),
        13: .standard(proto: "user_relationships_with_version"),
        14: .standard(proto: "nearby_users"),
        15: .standard(proto: "group_invitations_with_version"),
        16: .standard(proto: "group_join_question_answer_result"),
        17: .standard(proto: "group_join_requests_with_version"),
        18: .standard(proto: "group_join_questions_with_version"),
        19: .standard(proto: "group_members_with_version"),
        20: .standard(proto: "groups_with_version"),
        50: .standard(proto: "storage_resource_infos"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v = v {
                        if self.kind != nil { try decoder.handleConflictingOneOf() }
                        self.kind = .long(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.kind != nil { try decoder.handleConflictingOneOf() }
                        self.kind = .string(v)
                    }
                }()
            case 3: try {
                    var v: LongsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .longsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .longsWithVersion(v)
                    }
                }()
            case 4: try {
                    var v: StringsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .stringsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .stringsWithVersion(v)
                    }
                }()
            case 5: try {
                    var v: Conversations?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .conversations(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .conversations(v)
                    }
                }()
            case 6: try {
                    var v: Messages?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .messages(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .messages(v)
                    }
                }()
            case 7: try {
                    var v: MessagesWithTotalList?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .messagesWithTotalList(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .messagesWithTotalList(v)
                    }
                }()
            case 8: try {
                    var v: UserSession?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userSession(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userSession(v)
                    }
                }()
            case 9: try {
                    var v: UserInfosWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userInfosWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userInfosWithVersion(v)
                    }
                }()
            case 10: try {
                    var v: UserOnlineStatuses?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userOnlineStatuses(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userOnlineStatuses(v)
                    }
                }()
            case 11: try {
                    var v: UserFriendRequestsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userFriendRequestsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userFriendRequestsWithVersion(v)
                    }
                }()
            case 12: try {
                    var v: UserRelationshipGroupsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userRelationshipGroupsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userRelationshipGroupsWithVersion(v)
                    }
                }()
            case 13: try {
                    var v: UserRelationshipsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .userRelationshipsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .userRelationshipsWithVersion(v)
                    }
                }()
            case 14: try {
                    var v: NearbyUsers?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nearbyUsers(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nearbyUsers(v)
                    }
                }()
            case 15: try {
                    var v: GroupInvitationsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupInvitationsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupInvitationsWithVersion(v)
                    }
                }()
            case 16: try {
                    var v: GroupJoinQuestionsAnswerResult?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupJoinQuestionAnswerResult(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupJoinQuestionAnswerResult(v)
                    }
                }()
            case 17: try {
                    var v: GroupJoinRequestsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupJoinRequestsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupJoinRequestsWithVersion(v)
                    }
                }()
            case 18: try {
                    var v: GroupJoinQuestionsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupJoinQuestionsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupJoinQuestionsWithVersion(v)
                    }
                }()
            case 19: try {
                    var v: GroupMembersWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupMembersWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupMembersWithVersion(v)
                    }
                }()
            case 20: try {
                    var v: GroupsWithVersion?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .groupsWithVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .groupsWithVersion(v)
                    }
                }()
            case 50: try {
                    var v: StorageResourceInfos?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .storageResourceInfos(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .storageResourceInfos(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch kind {
        case .long?: try {
                guard case let .long(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
            }()
        case .string?: try {
                guard case let .string(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .longsWithVersion?: try {
                guard case let .longsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .stringsWithVersion?: try {
                guard case let .stringsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .conversations?: try {
                guard case let .conversations(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .messages?: try {
                guard case let .messages(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .messagesWithTotalList?: try {
                guard case let .messagesWithTotalList(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .userSession?: try {
                guard case let .userSession(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case .userInfosWithVersion?: try {
                guard case let .userInfosWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case .userOnlineStatuses?: try {
                guard case let .userOnlineStatuses(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .userFriendRequestsWithVersion?: try {
                guard case let .userFriendRequestsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .userRelationshipGroupsWithVersion?: try {
                guard case let .userRelationshipGroupsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case .userRelationshipsWithVersion?: try {
                guard case let .userRelationshipsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            }()
        case .nearbyUsers?: try {
                guard case let .nearbyUsers(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            }()
        case .groupInvitationsWithVersion?: try {
                guard case let .groupInvitationsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            }()
        case .groupJoinQuestionAnswerResult?: try {
                guard case let .groupJoinQuestionAnswerResult(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            }()
        case .groupJoinRequestsWithVersion?: try {
                guard case let .groupJoinRequestsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
            }()
        case .groupJoinQuestionsWithVersion?: try {
                guard case let .groupJoinQuestionsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
            }()
        case .groupMembersWithVersion?: try {
                guard case let .groupMembersWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
            }()
        case .groupsWithVersion?: try {
                guard case let .groupsWithVersion(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
            }()
        case .storageResourceInfos?: try {
                guard case let .storageResourceInfos(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: TurmsNotification.DataMessage, rhs: TurmsNotification.DataMessage) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
