# 客户端与服务端之间采用的通讯协议

## 数据格式

对于一般请求与响应而言：

* 基于纯TCP协议实现的客户端：varint编码的正文长度 + 正文（Protobuf编码的`TurmsNotification`或`TurmsRequest`）。
* 基于WebSocket协议实现的客户端：正文（Protobuf编码的`TurmsNotification`或`TurmsRequest`）。正文的字节长度信息通过底层的WebSocket Frame传输。

对于心跳请求而言：

* 基于纯TCP协议实现的客户端：一个长度为一字节的`[0]`字节数组。这里的数值`0`其实是指“该Payload的长度在varint编码下为一字节长度的0”，即Payload为0字节。
* 基于WebSocket协议实现的客户端：一个正文为空（0字节）的Binary类型消息。

补充：Turms不通过WebSocket的PING/PONG来实现心跳的原因是：

* 各浏览器WebSocket实现的PING帧发送时间间隔不同。
* 上层代码无法控制PING/PONG的行为，甚至无法感知行为的发生。
* 网络层面的心跳逻辑不应该和应用层的心跳耦合。

## XMPP

XMPP是一种以XML为基础的开放式即时通信协议。

Turms自身不采用XMPP协议的原因：

1. 设计非常低效。主要体现在两个方面：
   1. 数据格式采用了冗余低效的XML协议，其元数据很多时候比实际传输的数据还大。
   2. XMPP的流程设计中，存在大量低效设计，比如将用户头像图片转换成Base64文本进行传输，又比如用户修改了某些个人信息，服务端需要将该信息主动推送给其联系列表的所有用户。
2. 拓展性差。一些文章会说XMPP拓展性强，但这种“拓展性强”也只是相对于那些没啥拓展性的协议而言的。真正拓展性强的协议肯定是自研协议。

但考虑到以下几点，Turms服务端计划未来支持XMPP协议：

1. 大部分知名的XMPP开源服务端项目的技术架构老套，技术栈陈旧，并且性能都不怎么样。尽管部分开源XMPP服务端会宣传自己的架构可拓展性“Scalable”强，但其可拓展性跟Turms比起来，就相形见绌了。Turms是在真正意义上，在架构、自身代码实现、数据库设计等方面，尽量把各方面（包括可拓展性）做到极致的项目，因此在中大型IM领域，Turms可以对其进行降维打击。
2. 复用互联网上丰富的XMPP客户端实现。

当然，由于XMPP自身存在很多低效的流程设计，因此Turms未来也不会支持这些设计。